import{ratioOf as t,minus as o,rotate as r,times as e,dot as i,lenOf as m,add as a,angleBetween as n}from"vector-math-fp";import{approxFix as p}from"approx-fix";const l={normal:"normal",ratio:"ratio",mirror:"mirror",mirrorRatio:"mirrorRatio"},s=l,f={left:"left",right:"right",top:"top",bottom:"bottom",leftTop:"leftTop",leftBottom:"leftBottom",rightTop:"rightTop",rightBottom:"rightBottom"},h=f,c=t=>Object.keys(t).map(t=>`'${t}'`).join(" | "),g=`Invalid 'mode' param, it can only be: ${c(l)}`,b=`Invalid 'marker' param, it can only be: ${c(f)}`,P={[s.normal]:!1,[s.ratio]:!0,[s.mirror]:!1,[s.mirrorRatio]:!0},B={[s.normal]:!1,[s.ratio]:!1,[s.mirror]:!0,[s.mirrorRatio]:!0},T=[1,0],v=[0,1],d={[h.left]:T,[h.right]:T,[h.top]:v,[h.bottom]:v},u={[h.left]:[-1,0],[h.right]:[1,0],[h.top]:[0,-1],[h.bottom]:[0,1],[h.leftTop]:[-1,-1],[h.leftBottom]:[-1,1],[h.rightTop]:[1,-1],[h.rightBottom]:[1,1]},R=t=>[t,1],k=t=>[t,-1],w={[h.leftTop]:R,[h.leftBottom]:k,[h.rightTop]:k,[h.rightBottom]:R},x=(t,[o,r])=>[o,o/t],y=(t,[o,r])=>[r*t,r],$={[h.left]:x,[h.right]:x,[h.top]:y,[h.bottom]:y},j=({startPos:n,opts:s={}})=>{const{center:h,size:c,rotate:T}=n;let{startPoint:v=[0,0],movePoint:R=[0,0],mode:k="normal",marker:x=null}=s;const y={};if(!l[k])throw g;if(!f[x])throw b;const j=d[x],z=void 0!==j,I=u[x],M=w[x],O=$[x],q=P[k],A=B[k];let C,D=t(c),E=o(v,R),F=r(-T,E);if(q)if(z)F=e(j,F),C=O(D,C=e(I,F));else{const t=M(D);F=t.map(o=>o*i(t,F)/Math.pow(m(t),2)),C=e(I,F)}else z&&(F=e(j,F)),C=e(I,F);return A&&(C=C.map(t=>2*t)),y.size=a(c,C).map(Math.abs).map(p),A||(y.center=a(h,r(T,e([.5,.5],F))).map(p)),y},z=({startPos:t,opts:r={}})=>{const{startPoint:e=[0,0],movePoint:i=[0,0]}=r,{center:m}=t,n={};return n.center=a(m)(o(e,i)),n},I=({startPos:t,opts:r={}})=>{const{startPoint:e=[0,0],movePoint:i=[0,0]}=r,{center:m,rotate:a}=t,p={};return p.rotate=a+n(o(m,e),o(m,i)),p};export{f as markerChoice,l as modeChoice,z as move,j as resize,I as rotate};
