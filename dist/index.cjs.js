"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var vectorMathFp=require("vector-math-fp"),approxFix=require("approx-fix");const modeChoice={normal:"normal",ratio:"ratio",mirror:"mirror",mirrorRatio:"mirrorRatio"},md=modeChoice,markerChoice={left:"left",right:"right",top:"top",bottom:"bottom",leftTop:"leftTop",leftBottom:"leftBottom",rightTop:"rightTop",rightBottom:"rightBottom"},mk=markerChoice,mapKeyStr=t=>Object.keys(t).map(t=>`'${t}'`).join(" | "),modeChoiceErrMsg=`Invalid 'mode' param, it can only be: ${mapKeyStr(modeChoice)}`,markerChoiceErrMsg=`Invalid 'marker' param, it can only be: ${mapKeyStr(markerChoice)}`,isRatioModeMap={[md.normal]:!1,[md.ratio]:!0,[md.mirror]:!1,[md.mirrorRatio]:!0},isMirrorModeMap={[md.normal]:!1,[md.ratio]:!1,[md.mirror]:!0,[md.mirrorRatio]:!0},axisX=[1,0],axisY=[0,1],inputAxisFilter={[mk.left]:axisX,[mk.right]:axisX,[mk.top]:axisY,[mk.bottom]:axisY},l=-1,r=1,t=-1,b=1,inputToSizeFilter={[mk.left]:[l,0],[mk.right]:[1,0],[mk.top]:[0,t],[mk.bottom]:[0,1],[mk.leftTop]:[l,t],[mk.leftBottom]:[l,1],[mk.rightTop]:[1,t],[mk.rightBottom]:[1,1]},k1=t=>[t,1],k2=t=>[t,-1],ratioCornerOperator={[mk.leftTop]:k1,[mk.leftBottom]:k2,[mk.rightTop]:k2,[mk.rightBottom]:k1},rx=(t,[r,o])=>[r,r/t],ry=(t,[r,o])=>[o*t,o],ratioEdgeOperator={[mk.left]:rx,[mk.right]:rx,[mk.top]:ry,[mk.bottom]:ry},resize=({startPos:t,opts:r={}})=>{const{center:o,size:e,rotate:i}=t;let{startPoint:a=[0,0],movePoint:m=[0,0],mode:p="normal",marker:s=null}=r;const c={};if(!modeChoice[p])throw modeChoiceErrMsg;if(!markerChoice[s])throw markerChoiceErrMsg;const h=inputAxisFilter[s],n=void 0!==h,l=inputToSizeFilter[s],k=ratioCornerOperator[s],d=ratioEdgeOperator[s],M=isRatioModeMap[p],v=isMirrorModeMap[p];let x,F=vectorMathFp.ratioOf(e),f=vectorMathFp.minus(a,m),g=vectorMathFp.rotate(-i,f);if(M)if(n)g=vectorMathFp.times(h,g),x=d(F,x=vectorMathFp.times(l,g));else{const t=k(F);g=t.map(r=>r*vectorMathFp.dot(t,g)/Math.pow(vectorMathFp.lenOf(t),2)),x=vectorMathFp.times(l,g)}else n&&(g=vectorMathFp.times(h,g)),x=vectorMathFp.times(l,g);return v&&(x=x.map(t=>2*t)),c.size=vectorMathFp.add(e,x).map(Math.abs).map(approxFix.approxFix),v||(c.center=vectorMathFp.add(o,vectorMathFp.rotate(i,vectorMathFp.times([.5,.5],g))).map(approxFix.approxFix)),c},move=({startPos:t,opts:r={}})=>{const{startPoint:o=[0,0],movePoint:e=[0,0]}=r,{center:i}=t,a={};return a.center=vectorMathFp.add(i)(vectorMathFp.minus(o,e)),a},rotate=({startPos:t,opts:r={}})=>{const{startPoint:o=[0,0],movePoint:e=[0,0]}=r,{center:i,rotate:a}=t,m={};return m.rotate=a+vectorMathFp.angleBetween(vectorMathFp.minus(i,o),vectorMathFp.minus(i,e)),m};exports.markerChoice=markerChoice,exports.modeChoice=modeChoice,exports.move=move,exports.resize=resize,exports.rotate=rotate;
